<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Blackjack — Bot Target</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #1a6b35;
    font-family: 'Segoe UI', Arial, sans-serif;
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    user-select: none;
  }
  h1 { margin: 12px 0 4px; font-size: 22px; letter-spacing: 2px; opacity: 0.7; }

  /* ── Table layout ─────────────────────────────────────── */
  #table {
    width: 820px;
    height: 520px;
    position: relative;
    border: 3px solid rgba(255,255,255,0.15);
    border-radius: 180px;
    margin: 10px auto;
    background: radial-gradient(ellipse at center, #1e8745 0%, #145a2e 100%);
  }

  /* Card zones */
  .zone {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
    justify-content: center;
    min-height: 120px;
  }
  #dealer-zone { top: 40px; }
  #player-zone { bottom: 40px; }

  .zone-label {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    font-size: 13px;
    opacity: 0.5;
    letter-spacing: 1px;
  }
  #dealer-label { top: 18px; }
  #player-label { bottom: 18px; }

  /* ── Cards ────────────────────────────────────────────── */
  .card {
    width: 80px;
    height: 115px;
    background: #fff;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 2px 3px 8px rgba(0,0,0,0.4);
    position: relative;
    transition: transform 0.3s;
  }
  .card img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 8px;
    display: block;
  }
  .card.facedown {
    background: repeating-linear-gradient(
      45deg, #1a3a7a, #1a3a7a 5px, #1e4490 5px, #1e4490 10px
    );
    border: 2px solid #0e2654;
  }

  /* ── Totals ───────────────────────────────────────────── */
  .total-badge {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.65);
    padding: 3px 14px;
    border-radius: 12px;
    font-size: 16px;
    font-weight: bold;
  }
  #dealer-total { top: 170px; }
  #player-total { bottom: 170px; }

  /* ── Info bar ─────────────────────────────────────────── */
  #info {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 26px;
    font-weight: bold;
    text-shadow: 0 2px 6px rgba(0,0,0,0.5);
    text-align: center;
    opacity: 0;
    transition: opacity 0.4s;
    pointer-events: none;
  }
  #info.show { opacity: 1; }

  /* ── Controls ─────────────────────────────────────────── */
  #controls {
    display: flex;
    gap: 12px;
    margin: 10px 0 20px;
  }
  button {
    padding: 12px 32px;
    font-size: 16px;
    font-weight: bold;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    letter-spacing: 1px;
    transition: background 0.15s, transform 0.1s;
  }
  button:active { transform: scale(0.96); }
  button:disabled { opacity: 0.35; cursor: default; transform: none; }
  #btn-deal   { background: #f1c40f; color: #333; }
  #btn-hit    { background: #27ae60; color: #fff; }
  #btn-stand  { background: #e74c3c; color: #fff; }
  #btn-double { background: #8e44ad; color: #fff; }

  #score-bar {
    font-size: 14px;
    opacity: 0.6;
    margin-bottom: 10px;
  }

  /* ── Bot overlay canvas ────────────────────────────────── */
  #overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 820px;
    height: 520px;
    pointer-events: none;
    z-index: 100;
  }

  /* ── Bot HUD ────────────────────────────────────────────── */
  #bot-hud {
    display: flex;
    align-items: center;
    gap: 18px;
    margin: 6px 0 14px;
    padding: 10px 24px;
    background: rgba(0,0,0,0.55);
    border-radius: 8px;
    font-size: 14px;
    flex-wrap: wrap;
    justify-content: center;
  }
  #bot-hud .hud-item { white-space: nowrap; }
  #bot-hud .hud-label { opacity: 0.6; margin-right: 4px; }
  #bot-hud .hud-sublabel { opacity: 0.4; font-size: 10px; display: block; margin-top: -2px; }
  #bot-hud .hud-value { font-weight: bold; font-size: 16px; }
  #bot-hud button {
    padding: 6px 16px;
    font-size: 13px;
    border-radius: 4px;
  }
  #btn-start-bot { background: #2ecc71; color: #fff; }
  #btn-start-bot.running { background: #e74c3c; }
  #btn-pause-bot { background: #f39c12; color: #fff; display: none; }
  #btn-pause-bot.paused { background: #3498db; }
  #btn-reset-count { background: #3498db; color: #fff; }

  /* Pipeline status badges */
  .hud-status {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 3px;
    font-size: 11px;
    font-weight: bold;
    letter-spacing: 0.5px;
  }
  .hud-status.ready { background: #27ae60; color: #fff; }
  .hud-status.computing { background: #f39c12; color: #fff; }
  .hud-status.idle { background: #555; color: #aaa; }
  .hud-status.scanning { background: #e67e22; color: #fff; }
  .hud-status.done { background: #2ecc71; color: #fff; }
  .hud-status.error { background: #e74c3c; color: #fff; }

  /* ── Model Perception Panel ────────────────────────────── */
  #model-section {
    width: 860px;
    margin: 10px 0 20px;
    text-align: center;
  }
  #model-section h2 {
    font-size: 18px;
    letter-spacing: 2px;
    opacity: 1;
    color: #f1c40f;
    margin-bottom: 6px;
  }
  #model-view-wrap {
    position: relative;
    display: inline-block;
    border: 2px solid rgba(255,255,255,0.15);
    border-radius: 8px;
    overflow: hidden;
    transition: border-color 0.3s;
  }
  #model-view-wrap.flash { border-color: #2ecc71; }
  #model-view {
    display: block;
    background: #111;
  }
  #detection-readout {
    margin-top: 6px;
    font-size: 14px;
    font-family: monospace;
    opacity: 0.85;
    min-height: 18px;
  }

  /* ── Detection List ────────────────────────────────────── */
  #detection-list {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
    margin-top: 10px;
    min-height: 20px;
  }
  .det-card {
    background: rgba(0,0,0,0.5);
    border-radius: 6px;
    padding: 6px 12px;
    font-size: 13px;
    font-family: monospace;
    border-left: 4px solid #555;
    text-align: left;
    min-width: 120px;
  }
  .det-card.dealer { border-left-color: #f39c12; }
  .det-card.player { border-left-color: #2ecc71; }
  .det-card .det-name { font-weight: bold; font-size: 15px; }
  .det-card .det-conf { opacity: 0.7; }
  .det-card .det-zone { opacity: 0.5; font-size: 11px; }
  .det-card .det-pass { color: #e67e22; font-size: 11px; font-weight: bold; }

  /* Decision source badge */
  .hud-status.model { background: #2ecc71; color: #fff; }
  .hud-status.fallback { background: #e74c3c; color: #fff; }

  /* ── Summary Modal ──────────────────────────────────── */
  #summary-modal-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.75);
    z-index: 9999;
    justify-content: center;
    align-items: center;
  }
  #summary-modal {
    background: #1a2a1a;
    border: 2px solid #2ecc71;
    border-radius: 12px;
    padding: 28px 36px;
    max-width: 560px;
    width: 90%;
    color: #fff;
    text-align: center;
    box-shadow: 0 8px 32px rgba(0,0,0,0.6);
  }
  #summary-modal h2 {
    font-size: 20px;
    letter-spacing: 3px;
    margin-bottom: 12px;
    color: #f1c40f;
  }
  .summary-result {
    font-size: 22px;
    font-weight: bold;
    margin-bottom: 4px;
  }
  .summary-result.win { color: #2ecc71; }
  .summary-result.loss { color: #e74c3c; }
  .summary-result.push { color: #f39c12; }
  .summary-totals {
    font-size: 14px;
    opacity: 0.7;
    margin-bottom: 16px;
  }
  .summary-section {
    margin: 12px 0;
    text-align: left;
  }
  .summary-section h3 {
    font-size: 12px;
    letter-spacing: 2px;
    opacity: 0.5;
    margin-bottom: 6px;
  }
  .summary-cards {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }
  .summary-card-tile {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 6px 12px;
    border-radius: 6px;
    font-family: monospace;
    font-size: 15px;
    font-weight: bold;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.1);
  }
  .summary-card-tile.detected { border-color: #2ecc71; }
  .summary-card-tile.missed { border-color: #e74c3c; }
  .summary-card-tile.false-pos { border-color: #e67e22; background: rgba(230,126,34,0.15); }
  .summary-card-tile .check { color: #2ecc71; }
  .summary-card-tile .miss { color: #e74c3c; }
  .summary-stats {
    margin-top: 16px;
    padding-top: 12px;
    border-top: 1px solid rgba(255,255,255,0.1);
    font-size: 13px;
    opacity: 0.85;
    line-height: 1.8;
  }
  #btn-summary-continue {
    margin-top: 18px;
    padding: 10px 40px;
    font-size: 16px;
    background: #2ecc71;
    color: #fff;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: bold;
    letter-spacing: 1px;
  }
  #btn-summary-continue:hover { background: #27ae60; }
</style>
</head>
<body>

<h1>&#9824; BLACKJACK &#9824;</h1>

<div id="table">
  <div class="zone-label" id="dealer-label">DEALER</div>
  <div class="zone" id="dealer-zone"></div>
  <div class="total-badge" id="dealer-total"></div>

  <div id="info"></div>

  <div class="total-badge" id="player-total"></div>
  <div class="zone" id="player-zone"></div>
  <div class="zone-label" id="player-label">PLAYER</div>
  <canvas id="overlay" width="820" height="520"></canvas>
</div>

<div id="controls">
  <button id="btn-deal">DEAL</button>
  <button id="btn-hit" disabled>HIT</button>
  <button id="btn-stand" disabled>STAND</button>
  <button id="btn-double" disabled>DOUBLE</button>
</div>

<div id="score-bar">Wins: <span id="wins">0</span> &nbsp;|&nbsp; Losses: <span id="losses">0</span> &nbsp;|&nbsp; Pushes: <span id="pushes">0</span></div>

<div id="bot-hud">
  <button id="btn-start-bot">START BOT</button>
  <button id="btn-pause-bot">PAUSE</button>
  <button id="btn-reset-count">RESET COUNT</button>
  <div class="hud-item">
    <span class="hud-label">Strategy Action:</span><span class="hud-value" id="hud-action">&mdash;</span>
    <span class="hud-sublabel">from game state (instant)</span>
  </div>
  <div class="hud-item"><span class="hud-label">Strategy:</span><span class="hud-status ready" id="hud-strategy">READY</span></div>
  <div class="hud-item"><span class="hud-label">YOLO:</span><span class="hud-status idle" id="hud-yolo">IDLE</span></div>
  <div class="hud-item"><span class="hud-label">Source:</span><span class="hud-status idle" id="hud-source">&mdash;</span></div>
  <div class="hud-item"><span class="hud-label">Dealer:</span><span class="hud-value" id="hud-dealer">&mdash;</span></div>
  <div class="hud-item"><span class="hud-label">Player:</span><span class="hud-value" id="hud-player">&mdash;</span></div>
  <div class="hud-item"><span class="hud-label">Running:</span><span class="hud-value" id="hud-running">0</span></div>
  <div class="hud-item"><span class="hud-label">True:</span><span class="hud-value" id="hud-true">0.0</span></div>
  <div class="hud-item"><span class="hud-label">Seen:</span><span class="hud-value" id="hud-seen">0</span></div>
</div>

<div id="model-section">
  <h2>MODEL PERCEPTION</h2>
  <div id="model-view-wrap">
    <canvas id="model-view" width="820" height="520"></canvas>
  </div>
  <div id="detection-readout">Waiting for bot...</div>
  <div id="detection-list"></div>
</div>

<script>
// ── Deck & helpers ─────────────────────────────────────────────────
const SUITS = ['\u2660','\u2665','\u2666','\u2663'];
const SUIT_CODES = ['s','h','d','c'];
const RANKS = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];

// ── URL parameters ────────────────────────────────────────────────
const _params = new URLSearchParams(window.location.search);
const GAME_SEED = _params.has('seed') ? parseInt(_params.get('seed'), 10) : null;
const BOT_SPEED = Math.max(0.25, Math.min(10, parseFloat(_params.get('speed')) || 2));

// ── Seeded PRNG (mulberry32) ──────────────────────────────────────
function _mulberry32(a) {
  return function() {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}
const _rng = GAME_SEED !== null ? _mulberry32(GAME_SEED) : () => Math.random();
if (GAME_SEED !== null) console.log(`[game] Seeded with: ${GAME_SEED}`);
console.log(`[game] Bot speed multiplier: ${BOT_SPEED}x (use ?speed=N to change)`);

function makeDeck(n = 6) {
  let deck = [];
  for (let d = 0; d < n; d++)
    for (let s = 0; s < 4; s++)
      for (let r = 0; r < 13; r++)
        deck.push({ rank: RANKS[r], suit: SUITS[s], suitCode: SUIT_CODES[s] });
  return shuffle(deck);
}

function shuffle(a) {
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(_rng() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function cardValue(rank) {
  if ('JQK'.includes(rank)) return 10;
  if (rank === 'A') return 11;
  return parseInt(rank);
}

function handTotal(cards) {
  let total = cards.reduce((s, c) => s + cardValue(c.rank), 0);
  let aces = cards.filter(c => c.rank === 'A').length;
  while (total > 21 && aces > 0) { total -= 10; aces--; }
  return total;
}

function isRed(suit) { return suit === '\u2665' || suit === '\u2666'; }

// ── State ──────────────────────────────────────────────────────────
let shoe = makeDeck(6);
let dealer = [], player = [];
let gameOver = true;
let stats = { wins: 0, losses: 0, pushes: 0 };

const $dealerZone = document.getElementById('dealer-zone');
const $playerZone = document.getElementById('player-zone');
const $dealerTotal = document.getElementById('dealer-total');
const $playerTotal = document.getElementById('player-total');
const $info = document.getElementById('info');
const $deal = document.getElementById('btn-deal');
const $hit = document.getElementById('btn-hit');
const $stand = document.getElementById('btn-stand');
const $double = document.getElementById('btn-double');

// ── Rendering ──────────────────────────────────────────────────────
function renderCard(card, facedown = false) {
  const el = document.createElement('div');
  el.className = 'card' + (facedown ? ' facedown' : '');
  if (!facedown) {
    const name = card.rank + card.suitCode;
    el.innerHTML = `<img src="/game/cards/${name}.png" alt="${name}" draggable="false">`;
  }
  return el;
}

function render(revealDealer = false) {
  $dealerZone.innerHTML = '';
  $playerZone.innerHTML = '';

  dealer.forEach((c, i) => {
    const hidden = (i === 1 && !revealDealer && !gameOver);
    $dealerZone.appendChild(renderCard(c, hidden));
  });

  player.forEach(c => $playerZone.appendChild(renderCard(c)));

  // Totals
  if (revealDealer || gameOver) {
    $dealerTotal.textContent = handTotal(dealer);
  } else {
    $dealerTotal.textContent = cardValue(dealer[0].rank);  // show upcard value only
  }
  $playerTotal.textContent = handTotal(player);
}

function showInfo(msg) {
  $info.textContent = msg;
  $info.classList.add('show');
}
function hideInfo() {
  $info.classList.remove('show');
}

function updateStats() {
  document.getElementById('wins').textContent = stats.wins;
  document.getElementById('losses').textContent = stats.losses;
  document.getElementById('pushes').textContent = stats.pushes;
}

function setButtons(dealing) {
  $deal.disabled = !dealing;
  $hit.disabled = dealing;
  $stand.disabled = dealing;
  $double.disabled = dealing || player.length !== 2;
}

// ── Game logic ─────────────────────────────────────────────────────
function draw() {
  if (shoe.length < 20) shoe = makeDeck(6);
  return shoe.pop();
}

function deal() {
  hideInfo();
  dealer = [draw(), draw()];
  player = [draw(), draw()];
  gameOver = false;
  render();
  setButtons(false);

  // Check naturals
  if (handTotal(player) === 21) {
    stand(); // auto-resolve
  }
}

function hit() {
  if (gameOver) return;
  player.push(draw());
  render();
  if (handTotal(player) > 21) {
    endRound('BUST \u2014 You lose');
    stats.losses++;
    updateStats();
  } else if (handTotal(player) === 21) {
    stand();
  }
  // Disable double after first hit
  $double.disabled = true;
}

function doDouble() {
  if (gameOver || player.length !== 2) return;
  player.push(draw());
  render();
  if (handTotal(player) > 21) {
    endRound('BUST \u2014 You lose');
    stats.losses++;
    updateStats();
  } else {
    stand();
  }
}

function stand() {
  if (gameOver) return;
  // Dealer draws to 17+
  render(true);
  dealerPlay();
}

function dealerPlay() {
  gameOver = true;
  const step = () => {
    render(true);
    if (handTotal(dealer) < 17) {
      dealer.push(draw());
      setTimeout(step, 400 * BOT_SPEED);
    } else {
      resolve();
    }
  };
  step();
}

function resolve() {
  const pt = handTotal(player);
  const dt = handTotal(dealer);
  render(true);

  if (dt > 21) {
    showInfo('Dealer busts \u2014 You win!');
    stats.wins++;
  } else if (pt > dt) {
    showInfo('You win!');
    stats.wins++;
  } else if (dt > pt) {
    showInfo('Dealer wins');
    stats.losses++;
  } else {
    showInfo('Push');
    stats.pushes++;
  }
  updateStats();
  setButtons(true);
}

function endRound(msg) {
  gameOver = true;
  render(true);
  showInfo(msg);
  setButtons(true);
}

function clearTable() {
  dealer = [];
  player = [];
  $dealerZone.innerHTML = '';
  $playerZone.innerHTML = '';
  $dealerTotal.textContent = '';
  $playerTotal.textContent = '';
  hideInfo();
}

// ── Event listeners ────────────────────────────────────────────────
$deal.addEventListener('click', deal);
$hit.addEventListener('click', hit);
$stand.addEventListener('click', stand);
$double.addEventListener('click', doDouble);

// Keyboard shortcuts (useful for manual testing)
document.addEventListener('keydown', e => {
  if (e.key === 'd' && !$deal.disabled) deal();
  if (e.key === 'h' && !$hit.disabled) hit();
  if (e.key === 's' && !$stand.disabled) stand();
  if (e.key === 'x' && !$double.disabled) doDouble();
});

// Init
setButtons(true);
</script>

<!-- ── Bot Script ────────────────────────────────────────────────── -->
<script>
(function () {
  // ── DOM refs ──────────────────────────────────────────────────
  const overlayCanvas = document.getElementById('overlay');
  const olCtx = overlayCanvas.getContext('2d');
  const modelCanvas = document.getElementById('model-view');
  const mvCtx = modelCanvas.getContext('2d');
  const modelWrap = document.getElementById('model-view-wrap');
  const $readout = document.getElementById('detection-readout');
  const $detList = document.getElementById('detection-list');
  const $startBot = document.getElementById('btn-start-bot');
  const $pauseBot = document.getElementById('btn-pause-bot');
  const $resetCount = document.getElementById('btn-reset-count');
  const $hudAction = document.getElementById('hud-action');
  const $hudStrategy = document.getElementById('hud-strategy');
  const $hudYolo = document.getElementById('hud-yolo');
  const $hudSource = document.getElementById('hud-source');
  const $hudDealer = document.getElementById('hud-dealer');
  const $hudPlayer = document.getElementById('hud-player');
  const $hudRunning = document.getElementById('hud-running');
  const $hudTrue = document.getElementById('hud-true');
  const $hudSeen = document.getElementById('hud-seen');

  let botRunning = false;
  let botPaused = false;
  let botTimer = null;
  let handInProgress = false;
  let modelActionCount = 0;
  let fallbackActionCount = 0;
  let botActive = false;
  let handStats = { scans: 0, detections: 0, correct: 0, wrong: 0 };

  function resetHandStats() {
    handStats = { scans: 0, detections: 0, correct: 0, wrong: 0 };
  }

  function tallyDetection(detData) {
    if (!detData || !detData.detections) return;
    handStats.scans++;

    const detCards = [
      ...(detData.dealer_cards || []),
      ...(detData.player_cards || [])
    ];
    handStats.detections += detCards.length;

    // Compare to visible actual cards (upcard only during play)
    const visibleDealer = gameOver
      ? dealer.map(c => c.rank + c.suitCode)
      : (dealer.length ? [dealer[0].rank + dealer[0].suitCode] : []);
    const visiblePlayer = player.map(c => c.rank + c.suitCode);
    const actualVisible = [...visibleDealer, ...visiblePlayer];

    const pool = [...detCards];
    let correct = 0;
    for (const card of actualVisible) {
      const idx = pool.indexOf(card);
      if (idx !== -1) {
        correct++;
        pool.splice(idx, 1);
      }
    }
    handStats.correct += correct;
    handStats.wrong += pool.length;
  }

  const SUIT_SYMBOLS = { s: '\u2660', h: '\u2665', d: '\u2666', c: '\u2663' };
  const SUIT_COLORS  = { s: '#ddd', h: '#e74c3c', d: '#e74c3c', c: '#ddd' };

  const sleep = ms => new Promise(r => setTimeout(r, ms));

  // ── Status helpers ────────────────────────────────────────────
  function setYoloStatus(status, text) {
    $hudYolo.className = 'hud-status ' + status;
    $hudYolo.textContent = text || status.toUpperCase();
  }

  function setStrategyStatus(status, text) {
    $hudStrategy.className = 'hud-status ' + status;
    $hudStrategy.textContent = text || status.toUpperCase();
  }

  function setSourceStatus(source) {
    if (source === 'model') {
      $hudSource.className = 'hud-status model';
      $hudSource.textContent = 'MODEL';
    } else {
      $hudSource.className = 'hud-status fallback';
      $hudSource.textContent = 'FALLBACK';
    }
  }

  // ── Get card names from JS game state ─────────────────────────
  function getPlayerCardNames() {
    return player.map(c => c.rank + c.suitCode);
  }
  function getDealerUpcard() {
    return dealer.length ? dealer[0].rank + dealer[0].suitCode : null;
  }

  // ── Ask backend for strategy (instant, from JS game state) ────
  async function getStrategy() {
    const playerCards = getPlayerCardNames();
    const dealerUpcard = getDealerUpcard();
    if (!playerCards.length || !dealerUpcard) return null;

    setStrategyStatus('computing', 'COMPUTING');
    const resp = await fetch('/api/strategy', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        player_cards: playerCards,
        dealer_upcard: dealerUpcard,
        can_double: player.length === 2,
      }),
    });
    const data = await resp.json();
    setStrategyStatus('ready', 'READY');
    return data;
  }

  // ── Execute the recommended action ────────────────────────────
  function executeAction(action) {
    const btnMap = {
      hit: document.getElementById('btn-hit'),
      stand: document.getElementById('btn-stand'),
      double: document.getElementById('btn-double'),
    };
    const btn = btnMap[action];
    if (btn && !btn.disabled) {
      btn.click();
      return true;
    }
    // Fall back: split → hit
    if (action === 'split') {
      const hitBtn = document.getElementById('btn-hit');
      if (!hitBtn.disabled) { hitBtn.click(); return true; }
    }
    return false;
  }

  // ── Update HUD ────────────────────────────────────────────────
  function updateHUD(data) {
    $hudAction.textContent = data.action.toUpperCase();
    $hudAction.style.color =
      data.action === 'hit' ? '#2ecc71' :
      data.action === 'stand' ? '#e74c3c' :
      data.action === 'double' ? '#8e44ad' : '#fff';
    $hudDealer.textContent = data.dealer_total || '\u2014';
    $hudPlayer.textContent = data.player_total || '\u2014';
    $hudRunning.textContent = data.running_count;
    $hudTrue.textContent = data.true_count;
    $hudSeen.textContent = data.cards_seen;
  }

  // ── Capture table → base64 PNG ────────────────────────────────
  async function captureTable() {
    const table = document.getElementById('table');
    const canvas = await html2canvas(table, {
      ignoreElements: el => el.id === 'overlay' || el.id === 'info',
      backgroundColor: null,
      useCORS: true,
      scale: 1,
      width: 820,
      height: 520,
    });
    return canvas.toDataURL('image/png');
  }

  // ── YOLO detection (backend) ──────────────────────────────────
  async function detectCards(imageData) {
    const resp = await fetch('/api/detect', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ image: imageData }),
    });
    return resp.json();
  }

  // ── Draw bounding boxes on main overlay ───────────────────────
  function drawOverlay(detections) {
    olCtx.clearRect(0, 0, 820, 520);
    for (const det of detections) {
      const [x1, y1, x2, y2] = det.bbox;
      const color = det.zone === 'dealer' ? '#f39c12' : '#2ecc71';

      olCtx.shadowColor = color;
      olCtx.shadowBlur = 8;
      olCtx.strokeStyle = color;
      olCtx.lineWidth = 3;
      olCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
      olCtx.shadowBlur = 0;

      let label = `${det.class_name} ${(det.confidence * 100).toFixed(0)}%`;
      if (det.pass_num && det.pass_num > 1) label += ` P${det.pass_num}`;
      olCtx.font = 'bold 13px monospace';
      const tw = olCtx.measureText(label).width;
      olCtx.fillStyle = color;
      olCtx.fillRect(x1, y1 - 19, tw + 8, 19);
      olCtx.fillStyle = '#000';
      olCtx.fillText(label, x1 + 4, y1 - 5);
    }
  }

  // ── Draw model-view canvas (full size, 1:1) ───────────────────
  function drawModelView(imageDataUrl, detections) {
    const img = new Image();
    img.onload = () => {
      mvCtx.clearRect(0, 0, 820, 520);
      mvCtx.drawImage(img, 0, 0, 820, 520);

      for (const det of detections) {
        const [x1, y1, x2, y2] = det.bbox;
        const color = det.zone === 'dealer' ? '#f39c12' : '#2ecc71';

        mvCtx.shadowColor = color;
        mvCtx.shadowBlur = 6;
        mvCtx.strokeStyle = color;
        mvCtx.lineWidth = 2;
        mvCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
        mvCtx.shadowBlur = 0;

        let label = `${det.class_name} ${(det.confidence * 100).toFixed(0)}%`;
        if (det.pass_num && det.pass_num > 1) label += ` P${det.pass_num}`;
        mvCtx.font = 'bold 12px monospace';
        const tw = mvCtx.measureText(label).width;
        mvCtx.fillStyle = color;
        mvCtx.fillRect(x1, y1 - 16, tw + 6, 16);
        mvCtx.fillStyle = '#000';
        mvCtx.fillText(label, x1 + 3, y1 - 4);
      }

      modelWrap.classList.add('flash');
      setTimeout(() => modelWrap.classList.remove('flash'), 400);
    };
    img.src = imageDataUrl;
  }

  // ── Update detection readout text ─────────────────────────────
  function updateReadout(detections, totalPasses) {
    if (!detections.length) {
      $readout.textContent = 'No cards detected by model';
      return;
    }
    const passInfo = totalPasses > 1 ? ` (${totalPasses} passes)` : '';
    $readout.textContent = `Detected ${detections.length} cards${passInfo}`;
  }

  // ── Update structured detection list ──────────────────────────
  function updateDetectionList(detections) {
    $detList.innerHTML = '';
    if (!detections.length) return;

    const sorted = [...detections].sort((a, b) => {
      const zoneOrder = { dealer: 0, player: 1, unknown: 2 };
      const za = zoneOrder[a.zone] || 2;
      const zb = zoneOrder[b.zone] || 2;
      if (za !== zb) return za - zb;
      return b.confidence - a.confidence;
    });

    for (const det of sorted) {
      const card = document.createElement('div');
      card.className = 'det-card ' + (det.zone === 'dealer' ? 'dealer' : det.zone === 'player' ? 'player' : '');
      let html = `<span class="det-name">${det.class_name}</span> `;
      html += `<span class="det-conf">${(det.confidence * 100).toFixed(0)}%</span><br>`;
      html += `<span class="det-zone">${det.zone}</span>`;
      if (det.pass_num && det.pass_num > 1) {
        html += ` <span class="det-pass">P${det.pass_num}</span>`;
      }
      card.innerHTML = html;
      $detList.appendChild(card);
    }
  }

  // ── Run YOLO detection (awaitable, returns data) ──────────────
  async function doDetection() {
    try {
      setYoloStatus('scanning', 'SCANNING...');
      $readout.textContent = 'Scanning...';
      const imageData = await captureTable();
      const data = await detectCards(imageData);
      const n = data.detections.length;
      setYoloStatus('done', n + ' card' + (n !== 1 ? 's' : ''));
      drawOverlay(data.detections);
      drawModelView(imageData, data.detections);
      updateReadout(data.detections, data.total_passes || 1);
      updateDetectionList(data.detections);
      return data;
    } catch (e) {
      console.error('[yolo]', e);
      setYoloStatus('error', 'ERROR');
      $readout.textContent = 'Detection error';
      return null;
    }
  }

  // ── Card display helpers for summary ──────────────────────────
  function formatCard(cardName) {
    const suit = cardName.slice(-1);
    const rank = cardName.slice(0, -1);
    const sym = SUIT_SYMBOLS[suit] || suit;
    const col = SUIT_COLORS[suit] || '#fff';
    return '<span style="color:' + col + '">' + rank + sym + '</span>';
  }

  function compareCards(actual, detected) {
    const pool = [...detected];
    const results = [];
    let correct = 0;
    for (const card of actual) {
      const idx = pool.indexOf(card);
      if (idx !== -1) {
        results.push({ card: card, detected: true });
        pool.splice(idx, 1);
        correct++;
      } else {
        results.push({ card: card, detected: false });
      }
    }
    return { results: results, correct: correct, falsePositives: pool };
  }

  // ── Hand summary modal ────────────────────────────────────────
  function showHandSummary(finalData) {
    const actualDealer = dealer.map(c => c.rank + c.suitCode);
    const actualPlayer = player.map(c => c.rank + c.suitCode);
    const detDealer = finalData ? (finalData.dealer_cards || []) : [];
    const detPlayer = finalData ? (finalData.player_cards || []) : [];

    const dealerComp = compareCards(actualDealer, detDealer);
    const playerComp = compareCards(actualPlayer, detPlayer);

    const totalActual = actualDealer.length + actualPlayer.length;
    const totalCorrect = dealerComp.correct + playerComp.correct;
    const accuracy = totalActual > 0 ? Math.round(totalCorrect / totalActual * 100) : 0;

    const pt = handTotal(player);
    const dt = handTotal(dealer);
    let resultText, resultClass;
    if (pt > 21)      { resultText = 'PLAYER BUSTS'; resultClass = 'loss'; }
    else if (dt > 21) { resultText = 'DEALER BUSTS \u2014 PLAYER WINS'; resultClass = 'win'; }
    else if (pt > dt) { resultText = 'PLAYER WINS'; resultClass = 'win'; }
    else if (dt > pt) { resultText = 'DEALER WINS'; resultClass = 'loss'; }
    else              { resultText = 'PUSH'; resultClass = 'push'; }

    function renderComparison(comp) {
      return comp.results.map(function(r) {
        const cls = r.detected ? 'detected' : 'missed';
        const icon = r.detected
          ? '<span class="check">\u2713</span>'
          : '<span class="miss">\u2717</span>';
        return '<div class="summary-card-tile ' + cls + '">' + formatCard(r.card) + ' ' + icon + '</div>';
      }).join('');
    }

    function renderFalsePositives(fps) {
      return fps.map(function(c) {
        return '<div class="summary-card-tile false-pos">' + formatCard(c) + ' <span class="miss">FP</span></div>';
      }).join('');
    }

    const allFP = dealerComp.falsePositives.concat(playerComp.falsePositives);

    let html = '<h2>HAND SUMMARY</h2>';
    html += '<div class="summary-result ' + resultClass + '">' + resultText + '</div>';
    html += '<div class="summary-totals">Player: ' + pt + ' | Dealer: ' + dt + '</div>';

    html += '<div class="summary-section"><h3>DEALER CARDS</h3>';
    html += '<div class="summary-cards">' + renderComparison(dealerComp) + '</div></div>';

    html += '<div class="summary-section"><h3>PLAYER CARDS</h3>';
    html += '<div class="summary-cards">' + renderComparison(playerComp) + '</div></div>';

    if (allFP.length > 0) {
      html += '<div class="summary-section"><h3>FALSE POSITIVES</h3>';
      html += '<div class="summary-cards">' + renderFalsePositives(allFP) + '</div></div>';
    }

    html += '<div class="summary-stats">';
    html += '<div>Final Snapshot: <strong>' + totalCorrect + '/' + totalActual + ' (' + accuracy + '%)</strong></div>';
    html += '<div>Decisions: <strong>' + modelActionCount + ' model</strong>, <strong>' + fallbackActionCount + ' fallback</strong></div>';
    html += '<div style="margin-top:8px;padding-top:8px;border-top:1px solid rgba(255,255,255,0.1)">All Scans This Hand: <strong>' + handStats.scans + '</strong></div>';
    html += '<div>Total Detections: <strong>' + handStats.detections + '</strong> &mdash; '
          + '<span style="color:#2ecc71">' + handStats.correct + ' correct</span>, '
          + '<span style="color:#e74c3c">' + handStats.wrong + ' wrong</span></div>';
    html += '</div>';

    html += '<button id="btn-summary-continue">CONTINUE</button>';

    document.getElementById('summary-modal').innerHTML = html;
    document.getElementById('summary-modal-overlay').style.display = 'flex';

    document.getElementById('btn-summary-continue').addEventListener('click', function() {
      document.getElementById('summary-modal-overlay').style.display = 'none';
      clearTable();
      olCtx.clearRect(0, 0, 820, 520);
      if (botRunning) botCycle();
    });
  }

  // ── Main bot cycle (fully synchronized, no setTimeout) ──────
  async function botCycle() {
    if (botActive) return;
    botActive = true;
    try {
      while (botRunning && !botPaused) {
        // ── Game over ───────────────────────────────────────────
        if (gameOver) {
          // Wait for dealer animation to finish
          if (document.getElementById('btn-deal').disabled) {
            await sleep(200);
            continue;
          }

          // Hand just finished → final detection + summary
          if (handInProgress) {
            handInProgress = false;
            await sleep(500 * BOT_SPEED);
            const finalData = await doDetection();
            tallyDetection(finalData);
            showHandSummary(finalData);
            return; // modal pauses bot; CONTINUE resumes
          }

          // Start new hand
          handInProgress = true;
          modelActionCount = 0;
          fallbackActionCount = 0;
          resetHandStats();
          olCtx.clearRect(0, 0, 820, 520);
          await fetch('/api/new_hand', { method: 'POST' });
          $hudAction.textContent = 'DEALING...';
          $hudAction.style.color = '#f1c40f';
          $hudSource.className = 'hud-status idle';
          $hudSource.textContent = '\u2014';
          document.getElementById('btn-deal').click();
          await sleep(1200 * BOT_SPEED);
          if (!botRunning || botPaused) return;
          const initData = await doDetection();
          tallyDetection(initData);
          await sleep(500 * BOT_SPEED);
          continue;
        }

        // ── Game in progress → detect, decide, act ──────────────
        const detData = await doDetection();
        tallyDetection(detData);

        let action = null;
        let source = 'model';

        // Try YOLO-based action
        if (detData && detData.action && detData.action !== 'none' &&
            detData.player_cards && detData.player_cards.length > 0 &&
            detData.dealer_cards && detData.dealer_cards.length > 0) {
          action = detData.action;
          source = 'model';
          updateHUD(detData);
        }

        // Fallback to JS game state
        if (!action) {
          const strat = await getStrategy();
          if (strat) {
            action = strat.action;
            source = 'fallback';
            updateHUD(strat);
          }
        }

        if (action) {
          if (source === 'model') modelActionCount++;
          else fallbackActionCount++;
          setSourceStatus(source);
        }

        if (!action) {
          await sleep(500 * BOT_SPEED);
          continue;
        }

        // Brief pause so user can read recommendation
        await sleep(800 * BOT_SPEED);
        if (!botRunning || gameOver || botPaused) continue;

        // Execute action
        executeAction(action);

        // Wait for game state to settle
        if (action === 'stand' || action === 'double') {
          await waitForGameOver();
        } else {
          await sleep(600 * BOT_SPEED);
        }
      }
    } catch (err) {
      console.error('[bot]', err);
    } finally {
      botActive = false;
    }
  }

  async function waitForGameOver() {
    const start = Date.now();
    while (!gameOver && Date.now() - start < 20000) {
      await sleep(200);
    }
    await sleep(300 * BOT_SPEED);
  }

  // ── Button handlers ───────────────────────────────────────────
  $startBot.addEventListener('click', function() {
    botRunning = !botRunning;
    if (botRunning) {
      $startBot.textContent = 'STOP BOT';
      $startBot.classList.add('running');
      $pauseBot.style.display = '';
      botPaused = false;
      handInProgress = false;
      $pauseBot.textContent = 'PAUSE';
      $pauseBot.classList.remove('paused');
      setYoloStatus('idle', 'IDLE');
      setStrategyStatus('ready', 'READY');
      $hudSource.className = 'hud-status idle';
      $hudSource.textContent = '\u2014';
      botCycle();
    } else {
      $startBot.textContent = 'START BOT';
      $startBot.classList.remove('running');
      $pauseBot.style.display = 'none';
      botPaused = false;
      handInProgress = false;
      clearTimeout(botTimer);
      olCtx.clearRect(0, 0, 820, 520);
      $hudAction.textContent = '\u2014';
      $hudAction.style.color = '#fff';
      setYoloStatus('idle', 'IDLE');
      setStrategyStatus('idle', 'IDLE');
      $hudSource.className = 'hud-status idle';
      $hudSource.textContent = '\u2014';
      document.getElementById('summary-modal-overlay').style.display = 'none';
    }
  });

  $pauseBot.addEventListener('click', function() {
    botPaused = !botPaused;
    if (botPaused) {
      $pauseBot.textContent = 'RESUME';
      $pauseBot.classList.add('paused');
      clearTimeout(botTimer);
    } else {
      $pauseBot.textContent = 'PAUSE';
      $pauseBot.classList.remove('paused');
      botCycle();
    }
  });

  $resetCount.addEventListener('click', async function() {
    const resp = await fetch('/api/reset_count', { method: 'POST' });
    const data = await resp.json();
    $hudRunning.textContent = data.running_count;
    $hudTrue.textContent = data.true_count;
    $hudSeen.textContent = 0;
  });
})();
</script>

<div id="summary-modal-overlay">
  <div id="summary-modal"></div>
</div>

</body>
</html>
